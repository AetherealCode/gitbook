---
description: предпросмотр
---

# Справочник по командам языка Ассемблер

Ц е л ь: описать набор команд Ассемблера и объяснить их машинные коды.

## ВВЕДЕНИЕ

В данной главе приведены объяснения машинных кодов и перечислены в алфавитном порядке символические коды команд с указанием их назначений. Многие специфические команды имеют однобайтовые машинные коды, например:

| Объектный код | Символические команды |
| :--- | :--- |
| 40 INC AX | Увеличение AX на 1 |
| 50 PUSH AX | Запись AХ в стек |
| С3 RET \(short\) | Короткий возврат из процедуры |
| CB RET \(far\) | Длинный возврат из процедуры |
| FD STD | Остановка флага направления |

Ни одна из перечисленных команд не использует прямой адресации памяти. Другие команды, использующие непосредственный операнд, 8-битовый регистр, регистровую пару или адрес памяти, требуют более сложного машинного кода.

### ОБОЗНАЧЕНИЕ РЕГИСТРОВ

Команды, использующие регистр, могут содержать три бита, указывающих на конкретный регистр, и один бит "w", определяющий размер регистра: байт или слово. Кроме того, лишь некоторые команды обеспечивают доступ к сегментным регистрам. На рис.25.1 показана полная идентификация регистров.

Рассмотрим команду MOV с однобайтовым непосредственным операндом:

`MOV АН,00 10110 100 00000000`

`| |`

`w rеg = AН`

**Основные, базовые и индексные регистры:**

Биты: w = 0 w = 1

`000 AL AX`

`001 CL CX`

`010 DL DX`

`011 BL BX`

`100 AH SP`

`101 CH BP`

`110 DH SI`

`111 BH DI`

Биты: Сегментный регистр:

`00 ES`

`01 CS`

`10 SS`

`11 DS`

Рис.25.1. Обозначение регистров

В данном случае первый байт машинного кода указывает на однобайтовый

размер \(w = 0\) и на регистр AН \(100\). Следующая команда MOV содержит

непосредственный двухбайтовый операнд:

MOV AX,00 10111 000 00000000 00000000

\| \|

w reg = AX

Первый байт машинного кода указывает на размер в одно слово \(w=1\) и на

регистр AХ \(000\). Не следует обобщать приведенные примеры, так как

указание регистра и бита w может быть в различных позициях кода.

БАЙТ СПОСОБА АДРЕСАЦИИ

Байт способа адресации, если он присутствует, занимает второй байт

машинного кода и состоит из следующих трех элементов:

1\) mod - двухбитового кода, имеющего значения 11 для ссылки на

регистр и 00, 01 и 10 для ссылки на память;

2\) reg - трехбитового указателя регистра;

3\) r/m - трехбитового указателя регистра или памяти \(r -

регистр, m - адрес памяти\).

Кроме того, первый байт машинного кода может содержать бит "а",

который указывает направление потока между операндом 1 и операндом 2.

Рассмотрим пример сложения содержимого регистра АХ с содержимым

регистра BX:

ADD BX,AX 00000011 11 011 000

dw mod reg r/m

В этом примере d=1 означает, что mod \(11\) и reg \(011\) описывают

операнд 1, а r/m \(000\) описывает операнд 2. Так как бит w=1, то размер

равен одному слову. Таким образом, команда должна прибавить AX \(OOQ\) к BХ

\(011\).

Второй байт команды в объектном коде указывает большинство способов

адресации памяти. В следующем разделе способы адресации будут подробно

рассмотрены.

Биты MOD

Два бита mod определяют адресацию регистра или памяти. Ниже

поясняется их назначение:

00 биты г/m дают абсолютный адрес, байт смещения \(относительный

адрес\) отсутствует;

01 биты г/m дают абсолютный адрес памяти и имеется один байт

смещения;

10 биты г/m дают абсолютный адрес и имеется два байта смещения;

11 биты г/m определяют регистр. Бит w \(в байте кода операции\)

определяет ссылку на восьми- или шестнадцатибитовый регистр.

Биты REG

Три бита reg \(вместе с битом w\) определяют конкретный восьми- или

шестнадцатибитовый регистр.

Биты R/M

Три бита г/m \(регистр/память\) совместно с битами mod определяют

способ адресации, как показано на рис.25.2.

r/m mod=00 mod=01 mod=10 mod=1.1 mod=11

w=0 w=1

000 BX+SI BX+SI+disp BX+SI+disp AL AX

001 BX+DI BX+DI+disp BX+DI+disp CL CX

010 BP+SI BP+SI+disp BP+SI+disp DL DX

011 BP+DI BP+DI+disp BP+DI+disp BL BX

100 SI SI+disp SI+disp AH SP

101 DI DI+disp DI+disp CH BP

110 Direct BP+disp BP+disp DH SI

111 BX BX+disp BX+disp BH DI

Рис.25.2. Биты r/m

ДВУХБАЙТОВЫЕ КОМАНДЫ

Рассмотрим пример сложения содержимого регистров BХ и AХ:

ADD BX,AX 0000 0011 11 011 000

dw mod reg r/m

d 1 означает, что биты reg и w описывают операнд 1 \(BХ\), а биты

mod, r/m и w - Операнд 2 \(AХ\);

w 1 определяет размер регистров в одно слово,

mod 11 указывает, что операнд 2 является регистром;

reg 011 указывает, что операнд 1 является регистром BХ;

r/m 000 указывает, что операнд 2 является регистром AX.

Рассмотрим пример умножения регистра AL на регистр BL:

MUL BL 11110110 11 100 011

w mod reg r/m

Команда MUL предполагает, что регистр AL содержит множимое. Размер

регистра равен одному байту \(w = 0\), mod указывает на регистровую

операцию, г/m = 011 указывает на регистр BL. В данном случае reg = 100 не

имеет смысла.

ТРЕХБАЙТОВЫЕ КОМАНДЫ

Следующая команда MOV генерирует три байте машинного кода:

MOV mem,AX 10100001 dddddddd dddddddd

Для команды пересылки из регистра AХ или AL необходимо знать, сколько

байтов участвует в операции: один или два. В данном примере w = 1 означает

слово, следовательно, предполагается 16-битовый регистр AХ. Использование

во втором операнде регистра AL приведет к значению бита w = 0. Байты 2 и 3

содержат относительный адрес памяти. Команды, использующие регистры АХ или

AL, часто генерируют более эффективный \(короткий\) машинный код.

ЧЕТЫРЕХБАЙТОВЫЕ КОМАНДЫ

Рассмотрим пример умножения регистра AL на значение в памяти.

Процессор предполагает, что множимое находится в регистре AL для

однобайтового умножения и в регистре AХ для Двухбайтового умножения:

MUL mem\_byte 11110110 00 100 110

w mod reg r/m

Для данной команды reg всегда имеет значение 100, mod = 00 указывает на

операцию с памятью, a r/m=110 - на прямой способ адресации. Машинная

команда также содержит два следующих байта, определяющих относительный

адрес памяти.

Рассмотрим еще один пример, иллюстрирующий команду LEA, которая

всегда специфицирует двухбайтовый адрес:

LEA DX,mem 10001101 00 010 110

LEA mod rеg r/m

Reg =010 означает регистр DX. Mod =00 и r/m=110 определяют прямой

способ адресации памяти. В следующих двух байтах содержится относительный

адрес.

КОМАНДЫ В АЛФАВИТНОМ ПОРЯДКЕ

В данном разделе представлен набор команд Ассемблера в алфавитном

порядке. Некоторые команды, например сдвиг и циклический сдвиг, для

краткости сгруппированы. Ряд специальных команд для процессоров 80186,

80286 и 80386 выходят за рамки данной книги и поэтому в данной главе также

отсутствуют. При пояснении команд и способов адресации используются

следующие сокращения:

addr адрес памяти;

addr-high первый байт адреса \(старший\);

addr-low левый \(младший\) байт. адреса;

data непосредственный операнд \(8 бит при w=0 и 16 бит при w= 1\);

data-high правый \(старший\) байт непосредственного операнда;

data-low левый \(младший\) байт непосредственного операнда;

disp смещение \(относительный адрес\);

rеg ссылка на регистр.

AAA: Коррекция ASCII-формата для сложения

О п е р а ц и я: Корректирует сумму двух ASCII-байтов в регистре AL.

Если правые четыре бита регистра AL имеют значение больше 9 или флаг AF

установлен в 1, то команда AAA прибавляет к регистру АН единицу и

устанавливает флаги AF и CF. Команда всегда очищает четыре левых бита в

регистре AL.

Ф л а г и: Команда воздействует на флаги AF и CF \(флаги OF, PF, SF и

ZF не определены\).

О б ъ е к т н ы й к о д: 00110111 \(без операндов\).

AAD: Коррекция ASCII-формата для деления

О п е р а ц и я: Корректирует ASCII-величины для деления. Команда AAD

используется перед делением неупакованных десятичных чисел в регистре AХ

\(удаляет тройки ASCII-кода\). Эта команда корректирует делимое в двоичное

значение в регистре AL для последующего двоичного деления. Затем умножает

содержимое регистра AН на 10. прибавляет результат к содержимому регистра

AL и очищает AН. Команда AAD не имеет операндов.

Ф л а г и: Команда воздействует на флаги PF, CF, ZF \(флаги AF CF и OF

не определены\).

О б ъ е к т н ы й к о д: \|11010101\|00001010\|.

AAМ: Коррекция ASCII-формата для умножения

О п е р а ц и я: Команда AAM используется для коррекции результата

умножения двух неупакованных десятичных чисел. Команда делит содержимое

регистра AL на 10, записывает частное в регистр AН, а остаток в регистр

AL.

Ф л а г и: Команда воздействует на флаги PF, SF и ZF \(флаги AF CF и

OF не определены\).

О б ъ е к т н ы й к о д: \|11010100\|00001010\| \(без операндов\).

AAS: Коррекция ASCII-формата для вычитания

О п е р а ц и я: Корректирует разность двух ASCII-байтов в регистре

AL. Если первые четыре бита имеют значение больше 9 или флаг CF установлен

в 1, то команда AAS вычитает 6 из регистра AL и 1 из регистра АН, флаги AF

и CF при этом устанавливаются в 1. Команда всегда очищает левые четыре

бита в регистре AL.

Ф л а г и: Команда воздействует на флаги AF и CF \(флаги OF PF SF и ZF

не определены\).

О б ъ е к т н ы й к о д: 00111111 \(без операндов\).

ADC: Сложение с переносом

О п е р а ц и я: Обычно используется при сложении многословных

величин для учета бита переполнения в последующих фазах операции. Если

флаг CF установлен в 1, то команда ADC сначала прибавляет 1 к операнду 1.

Команда всегда прибавляет операнд 2 к операнду 1, аналогично команде ADD.

Ф л а г и: Команда воздействует на флаги AF, CF, OF, PF, SF и ZF.

О б ъ е к т н ы й к о д \(три формата\):

Регистр плюс регистр или память:

\|000100dw\|modregr/m\|

Регистр АХ \(AL\) плюс непосредственное значение:

\|0001010w\|-- data--\|data, если w=1\|

Регистр или память плюс непосредственное значение:

y100000sw\|mod010r/m\|--data--\|data, если sw=01\|

ADD: Сложение двоичных чисел

О п е р а ц и я: Прибавляет один байт или одно слово в памяти,

регистре или непосредственно к содержимому регистра или прибавляет один

байт или слово в регистре или непосредственно к памяти.

Ф л а г и: Команда воздействует на флаги AF, CF, OF, PF, SF и ZF.

О б ъ е к т н ы й к о д \(три формата\):

Регистр плюс регистр или память:

\|000000dw\|modregr/rm\|

Регистр AX \(AL\) плюс непосредственное значение:

\|0000010w\|--data--\|data, если w=1\|

Регистр или память плюс непосредственное значение:

\|100000sw\|mod000r/m\|--data--\|data, если BW=01\|

AND: Логическое И

О п е р а ц и я: Команда выполняет поразрядную конъюнкцию \(И\) битов

двух операндов. Операнды представляют собой одно- или двухбайтовые

величины в регистре или памяти. Второй операнд может содержать

непосредственные данные. Команда AND проверяет два операнда поразрядно.

Если два проверяемых бита равны 1, то в первом операнде устанавливается

единичное значение бита, в других случаях - нулевое. См. также команды OR,

XOR и TEST.

Ф л а г и: Команда воздействует на флаги CF, OF, PF, SF и ZF \(флаг AF

не определен\).

О б ъ е к т н ы й к о д \(три формата\):

Регистр И регистр или память:

\|001000dw\|modregr/m\|

Регистр AX \(AL\) И непосредственное значение:

\|0010010w\|--data--\|data, если w=1\|

Регистр или память И непосредственное значение:

\|1010000w\|modl00r/m\|--data--\|data, если w=1\|

CALL: Вызов процедуры

О п е р а ц и я: Выполняет короткий или длинный вызов процедуры для

связи подпрограмм. Для возврата из процедуры используется команда RET.

Команда CALL уменьшает содержимое SP на 2 и заносит в стек адрес следующей

команды \(из IP\), а затем устанавливает в регистре IP относительный адрес

процедуры. Впоследствии команда RET использует значение в стеке для

возврата. Существует четыре типа команды CALL для вызова внутри сегмента и

между сегментами. Команда межсегментного вызова сначала уменьшает SP,

заносит в стек адрес из регистра CS, а затем загружает в стек

внутрисегментный указатель.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д \(четыре формата\):

Прямая адресация в сегменте:

\|11101000\|disp-low\|diep-high\|

Косвенная адресация в сегменте:

\|11111111\|mod010r/m\|

Косвенная адресация между сегментами:

\|11111111\|mod011r/m\|

Прямая адресация между сегментами:

\|10011010\|offset-low\|offset-high\|seg-low\|seg-high\|

CBW: Преобразование байта в слово

О п е р а ц и я: Расширяет однобайтовое арифметическое значение в

регистре AL до размеров слова. Команда CBW размножает знаковый бит \(7\) в

регистре AL по всем Битам регистра АН. См также команду CWD.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: 10011000 \(без операндов\).

CLC: Сброс флага переноса

О п е р а ц и я: Устанавливает значение флага переноса, равное 0, так

что, например, команда ADC не прибавляет единичный бит. Команда CLC не

имеет операндов. См. также команду STD.

Ф л а г и: Команда воздействует на флаг CF \(устанавливается в 0\).

О б ъ е к т н ы й к о д: 11111000.

CLD: Сброс флага направления

О п е р а ц и я: Устанавливает значение флага направления, равное 0.

В результате такие строковые операции, как CMPS или MOVS обрабатывают

данные слева направо. См. также команду STD.

Ф л а г и: Команда воздействует на флаг DF \(устанавливается в 0\).

О б ъ е к т н ы й к о д: 11111100 \(без операндов\).

CLI: Сброс флага прерывания

О п е р а ц и я: Запрещает маскируемые внешние прерывания по

процессорной шине INTR посредством установки значения флага прерывания IF

в 0. См. также команду STI.

Ф л а г и: Команда воздействует на флаг IF \(устанавливается в 0\).

О б ъ е к т н ы й к о д: 11111010 \(без операндов\).

CMC: Переключение флага переноса

О п е р а ц и я: Инвертирует флаг CF, т.е. преобразует нулевое

значение флага CF в единичное и наоборот.

Ф л а г и: Команда воздействует на флаг CF \(инвертируется\).

О б ъ е к т н ы й к о д: 11110101 \(без операндов\).

CMP: Сравнение

О п е р а ц и я: Сравнивает содержимое двух полей данных. Фактически

команда CMP вычитает второй операнд из первого, но содержимое полей не

изменяет. Операнды должны иметь одинаковую длину: байт или слово. Команда

CMP может сравнивать содержимое регистра, памяти или непосредственное

значение с содержимым регистра; или содержимое регистра или

непосредственное значение с содержимым памяти. См. также команду CMPS.

Ф л а г и: Команда воздействует на флаги AF, CF, OF, PF, SF и ZF.

О б ъ е к т н ы й к о д \(три формата\):

Регистр или память с регистром:

\|001110dw\|modregr/m\|

Непосредственное значение с регистром AX \(AL\):

\|0011110w\|--data--\|data, если w=1\|

Непосредственное значение с регистром или памятью:

\|100000sw\|mod111r/m\|--data--\|data, если sw=0\|

CMPS/CMPSB/CMPSW: Сравнение строк

О п е р а ц и я: Сравнивают строки любой длины. Этим командам обычно

предшествует префикс REPn, например REPE CMPSB. Команда CMPSB сравнивает

память по байтам, а команда CMPSW - по словам. Первый операнд этих команд

адресуется регистровой парой DS:SI, а второй - регистровой парой ES:DI.

Если флаг DF установлен в 0, то сравнение происходит слева направо,

регистры SI и DI при этом увеличиваются после каждого сравнения. Если флаг

DF установлен в 1, то сравнение происходит справа налево, а регистры SI и

DI при этом уменьшаются после каждого сравнения.

Ф л а г и: Команда воздействует на флаги AF, CF, OF, PF, SF и ZF.

О б ъ е к т н ы й к о д: 1010011w.

CWD: Преобразование слова в двойное слово

О п е р а ц и я: Расширяет арифметическое значение в регистре АХ до

размеров двойного слова в регистровой паре DX:AX, дублируя при этом

знаковый бит \(15-й бит в регистре АХ\) через регистр DX. Обычно

используется для получения 32-битового делимого. См. также команду CBW.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: 10011001 \(без операндов\).

DAA: Десятичная коррекция для сложения

О п е р а ц и я: Корректирует результат сложения двух BCD \(десятичных

упакованных\) элементов в регистре AL. Если четыре правых бита имеют

значение больше 9 или флаг AF установлен в 1, то команда DAA прибавляет 6

к регистру AL и устанавливает флаг AF. Если регистр AL содержит значение

больше, чем 9F, или флаг CF установлен в 1, то команда DAA прибавляет 60Н

к регистру AL и устанавливает флаг CF. См. также команду DAS.

Ф л а г и: Команда воздействует на флаги AF. CF, PF, SF и 2F \(флаг OF

неопределен\).

О б ъ е к т н ы й к о д: 00100111 \(без операндов\).

DAS: Десятичная коррекция для вычитания

О п е р а ц и я: Корректирует результат вычитания двух BCD

\(десятичных упакованных\) чисел в регистре AL. Если четыре правых бита

имеют значение больше 9 или флаг AF установлен в 1, то команда DAS

вычитает 60Н из регистра AL и устанавливает флаг CF. См. также команду

DAA.

Ф л а г и: Команда воздействует на флаги AF, CF, PF, SF и ZF.

О б ъ е к т н ы й к о д: 00101111 \(без операндов\).

DEC: Декремент

О п е р а ц и я: Вычитает 1 из байта или слова в регистре или в

памяти например DEC СХ. См. также команду INC.

Ф л а г и: Команда воздействует на флаги AF, OF, PF, SF и ZF.

О б ъ е к т н ы й к о д \(два формата\):

Регистр: \|01001reg\|

Регистр или память: \|1111111w\|mod001r/m\|

DIV: Деление

О п е р а ц и я: Выполняет деление беззнакового делимого \(16 или 32

бит\) на беззнаковый делитель \(8 или 16 бит\). Левый единичный бит

рассматривается как бит данных, а не как минус для отрицательных чисел.

Для 16-битового деления делимое должно находиться в регистре АХ, а

8-битовый делитель возможен в регистре или в памяти, например DIV BH.

Частное от деления получается в регистре AL, а остаток - в регистре AН.

Для 32-битового деления делимое должно находиться в регистровой паре DX:AX

а 16-битовый делитель возможен в регистре или в памяти, например DIV СХ.

Частное от деления получается в регистре AХ, а остаток - в регистре DX.

См. также команду IDIV.

Ф л а г и: Команда воздействует на флаги AF, CF, OF, PF SF и ZF \(все

не определены\).

О б ъ е к т н ы й к о д: \|1111011w\|mod110r/m\|

ESC: Переключение на сопроцессор

О п е р а ц и я: Обеспечивает использование сопроцессора для

выполнения специальных операций. Для выполнения арифметических операций

над числами с плавающей запятой используются сопроцессоры 8087 или 80287.

Команда ESC передает в сопроцессор инструкцию и операнд для выполнения

необходимой операции.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|11011xxx\|modxxxr/m\| \(x - любое знач.\).

HLT: Останов микропроцессора

О п е р а ц и я: Приводит процессор в состояние останова, в котором

происходит ожидание прерывания. При завершении команды HLT регистры CS:IP

указывают на следующую команду. При возникновении прерывания процессор

записывает в стек регистры CS и IP и выполняет подпрограмму обработки

прерывания. При возврате из подпрограммы команда IRET восстанавливает

регистры CS и IP из стека и управление передается на команду, следующую за

командой HLT.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: 11110100 \(без операндов\).

IDIV: Целое деление знаковых величин

О п е р а ц и я: Выполняет деление знакового делимого \(16 или 32 бит\)

на знаковый делитель \(8 или 16 бит\). Левый единичный бит рассматривается

как знак минус для отрицательных чисел. Для 16-битового деления делимое

должно находиться в регистре АХ, a 8-битовый делитель возможен в регистре

или в памяти, например IDIV DL. Частное от деления получается в регистре

AL, а остаток - в регистре АН. Для 32-битового деления делимое должно

находиться в регистровой паре DX:AX, а 16-битовый делитель возможен в

регистре или в памяти, например IDIV BX. Частное от деления получается в

регистре АХ, а остаток - в регистре DX. См. команды CBW и CWD для

расширения знакового делимого, а также команду DIV.

Ф л а г и: Команда воздействует на флаги AF, CF, OF, PF, SF и ZF.

О б ъ е к т н ы й к о д: \|1111011w\|mod111r/m\|

IMUL: Целое умножение знаковых величин

О п е р а ц и я: Выполняет умножение на знаковый множитель \(8 или 16

бит\). Левый единичный бит рассматривается как знак минус для отрицательных

чисел. Для 8-битового умножения множимое должно находиться в регистре AL,

а множитель возможен в регистре или в памяти, например IMUL BL.

Произведение получается в регистре АХ. Для 16-битового умножения множимое

должно находиться в регистре АХ, а множитель возможен в регистре или в

памяти, например IMUL BX. Произведение получается в регистровой паре

DX:AX. См. также команду MUL.

Ф л а г и: Команда воздействует на флаги CF и OF \(флаги AF PF SF и ZF

не определены\).

О б ъ е к т н ы й к о д: \|1111011w\|mod101r/m\|

IN: Ввод байта или слова из порта

О п е р а ц и я: Передает из вводного порта один байт в регистр AL

или два байта в регистр АХ\). Порт кодируется как фиксированный числовой

операнд \(IN АХ,порт\#\) или как переменная в регистре DX \(IN AX,DX\).

Процессоры 80186, 80286 и 80386 имеют, кроме того, команду INS \(Input

String - ввод строки\). См. также команду OUT.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д \(два формата\):

Переменный порт: \|1110110w\|

Фиксированный порт: \|1110010w\|--port--\|

INC: Инкремент

О п е р а ц и я: Прибавляет 1 к байту или слову в регистре или в

памяти, например INC СХ. См. также команду DEC.

Ф л а г и: Команда воздействует на флаги AF, OF, PF, SF и ZF.

О б ъ е к т н ы й к о д \(два формата\):

Регистр: \|01000reg\|

Регистр или память: \|1111111w\|mod000r/m\|

INT: Прерывание

О п е р а ц и я: Прерывает выполнение программы и передает управление

по одному из 256 адресов \(векторов прерывания\). Команда INT выполняет

следующее: 1\) уменьшает значение SP на 2 и заносит в стек флаговый

регистр, сбрасывает флаги IF и TF; 2\) уменьшает значение SP на 2 и заносит

регистр CS в стек, старшее слово из вектора прерывания помещает в регистр

CS; 3\) уменьшает значение SP на 2 и заносит регистр IP в стек, младшее

слово из вектора прерывания помещает в регистр IP.

Ф л а г и: Команда воздействует на флаги IF и TF.

О б ъ е к т н ы й к о д:

\|1100110v\|--type--\| \(если v = 0, то type = 3\).

INTO: Прерывание по переполнению

О п е р а ц и я: Приводит к прерыванию при возникновении переполнения

\(флаг OF установлен в 1\) и выполняет команду IRET 4. Адрес подпрограммы

обработки прерывания \(вектор прерывания\) находится по адресу 10Н. См.

также команду INT.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: 11001110 \(без операндов\).

IRET: Возврат из обработки прерывания

О п е р а ц и я: Обеспечивает возврат из подпрограммы обработки

прерывания. Команда IRET выполняет следующее: 1\) помещает слово из вершины

стека в регистр IP и увеличивает значение SP на 2; 2\) помещает слово из

вершины стека в регистр CS и увеличивает значение SP на 2; 3\) помещает

слово из вершины стека во флаговый регистр и увеличивает значение SP. на

1. См. также команду RET.

Ф л а г и: Команда воздействует на все флаги.

О б ъ е к т н ы й к о д: 11001111 \(бег операндов\).

JA/JNBE: Переход по "выше" или "не ниже или равно"

О п е р а ц и я: Используется после проверки беззнаковых данных для

передачи управления по другому адресу. Если флаг CF равен нулю \(нет

переноса\) и флаг ZF равен нулю \(не нуль\), то команда прибавляет к регистру

IP значение операнда \(относительное смещение\) и выполняет таким образом

переход.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|01110111\|--disp--\|

JAE/JNB: Переход по "выше или равно" или "не ниже"

О п е р а ц и я: Используется после проверки беззнаковых данных для

передачи управления по другому адресу. Если флаг CF равен нулю \(нет

переноса\), то команда прибавляет к регистру IP значение операнда

\(относительное смещение\) и выполняет таким образом переход.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|01110011\|--disp--\|

JB/JNAE: Переход по "ниже" или "не выше или равно"

О п е р а ц и я: Используется после проверки беззнаковых данных для

Передачи управления по другому адресу. Если флаг CF равен единице \(есть

перенос\), то команда прибавляет к регистру IP значение операнда

\(относительное смещение\) и выполняет таким образом переход.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|01110010\|--disp--\|

JBE/JNA: Переход по "ниже или равно" или "не выше"

О п е р а ц и я: Используется после проверки беззнаковых данных для

передачи управления по другому адресу. Если флаг CF равен единице \(есть

перенос\) или флаг AF равен единице, то команда прибавляет к регистру IP

значение операнда \(относительное смещение\) и выполняет таким образом

переход.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|01110110\|--disp--\|

JC: Переход по переносу

О п е р а ц и я: Идентична JB/JNAE.

JCXZ: Переход по "CX равно нулю"

О п е р а ц и я: Выполняет передачу управления по указанному в

операнде адресу, если значение в регистре CX равно нулю. Команда JCXZ

может быть полезна в начале циклов LOOP.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|11100011\|--disp--\|

JE/JZ: Переход по "равно" или по "нулю"

О п е р а ц и я: Используется после проверки знаковых или беззнаковых

данных для передачи управления по другому адресу. Если флаг ZF равен

единице \(нулевое состояние\), то команда прибавляет к регистру IP значение

операнда \(относительное смещение\) и выполняет таким образом переход.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|01110100\|--disp--\|

JG/JNLE: Переход по "больше" или "не меньше или равно"

О п е р а ц и я: Используется после проверки знаковых данных для

передачи управления по другому адресу. Если флаг ZF равен нулю \(не нуль\) и

флаги SF и OF одинаковы \(оба 0 или оба 1\), то команда прибавляет к

регистру IP значение операнда \(относительное смещение\) и выполняет таким

образом переход.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|01111111\|--disp--\|

JGE/JNL: Переход по "больше или равно" или "не меньше"

О п е р а ц и я: Используется после проверки знаковых данных для

передачи управления по другому адресу. Если флаги SF и OF одинаковы \(оба 0

или оба 1\), то команда прибавляет к регистру IP значение операнда

\(относительное смещение\) и выполняет таким образом переход.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|01111101\|--disp--\|

JL/JNGE: Переход по "меньше" или "не больше или равно"

О п е р а ц и я: Используется после проверки знаковых данных для

передачи управления по другому адресу. Если флаги SF и OF различны, то

команда прибавляет к регистру IP значение операнда \(относительное

смещение\) и выполняет таким образом переход.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|01111100\|--disp--\|

JLE/JNG: Переход по "меньше или равно" или "не больше"

О п е р а ц и я: Используется после проверки знаковых данных для

передачи управления по другому адресу. Если флаг ZF равен единице \(нулевое

состояние\) и флаги SF и OF различны, то команда прибавляет к регистру IP

значение операнда \(относительное смещение\) и выполняет таким образом

переход.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|01111110\|--disp--\|

JMP: Безусловный переход

О п е р а ц и я: Выполняет переход по указанному адресу при любых

условиях. Команда JMP заносит в регистр IP необходимый адрес перехода.

Существует пять типов команды JMP для передачи управления внутри сегмента

или между сегментами. При межсегментном переходе в регистр CS заносится

также новый сегментный адрес.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д \(пять форматов\):

Прямой переход внутри сегмента:

\|11101001\|disp-low\|disp-high\|

Прямой переход внутри сегмента \(короткий\):

\|11101011\|--disp--\|

Косвенный переход внутри сегмента:

\|11111111\|mod100r/m\|

Косвенный межсегментный переход:

\|11111111\|mod101r/m\|

Прямой межсегментный переход:

\|11101010\|offset-low\|offset-high\|seg-low\|seg-high\|

JNC: Переход если нет переноса

О п е р а ц и я: Идентична JAE/JNB.

JNE/JNZ: Переход по "не равно" или по "не нуль"

О п е р а ц и я: Используется после проверки знаковых данных для

передачи управления по другому адресу. Если флаг ZF равен нулю \(ненулевое

состояние\), то команда прибавляет к регистру IP значение операнда

\(относительное смещение\) и выполняет таким образом переход.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|01110101\|--disp--\|

INO: Переход, если нет переполнения

О п е р а ц и я: Используется для передачи управления по

определенному адресу после проверки на отсутствие переполнения. Если флаг

OF равен, нулю \(нет переполнения\), то команда прибавляет к регистру IP

значение операнда \(относительное смещение\) и выполняет таким образом

переход. См. также команду JO.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|01110001\|--disp--\|

JNP/JPO: Переход, если нет паритета или паритет нечетный

О п е р а ц и я: Приводит к передаче управления по определенному

адресу, если в результате операции обнаружено отсутствие паритета или

паритет нечетный. Нечетный паритет в данном случае означает, что в

результате операции в . младших восьми битах получено нечетное число

битов. Если флаг PF равен нулю \(нечетный паритет\), то команда прибавляет к

регистру IP значение операнда \(относительное смещение\) и выполняет таким

образом переход. См. также команду JP/JPE.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|01111011\|--disp--\|

JHS: Переход, если нет знака

О п е р а ц и я: Приводит к передаче управления по определенному

адресу, если в результате операции получен положительный знак. Если флаг

SF равен нулю \(положительное\), то команда JNS прибавляет к регистру IP

значение операнда \(относительное смещение\) и выполняет таким образом

переход. См. также команду JS.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|01111001\|--disp--\|

JO: Переход по переполнению

О п е р а ц и я: Приводит к передаче управления по определенному

адресу, если в результате операции получено состояние переполнения. Если

флаг OF равен единице \(переполнение\), то команда JO прибавляет к регистру

IP значение операнда \(относительное смещение\) и выполняет таким образом

переход. См. также команду JNO.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|01110000\|--disp--\|

JP/JPE: Переход, если есть паритет или паритет четный

О п е р а ц и я: Приводит к передаче управления по определенному

адресу, если в результате операции обнаружен четный паритет. Четный

паритет в данном случае означает, что в результате операции в младших

восьми битах получено четное число битов. Если флаг PF равен единице

\(четный паритет\), то команда прибавляет к регистру IP значение операнда

\(относительное смещение\) и выполняет таким образом переход. См. также

команду JNP/JPO.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|01111010\|--disp--\|

JS: Переход по знаку

О п е р а ц и я: Передает управления по определенному адресу, если в

результате операции получен отрицательный знак. Если флаг SF равен единице

\(отрицательно\), то команда JS прибавляет к регистру IP значение операнда

\(относительное смещение\) и выполняет таким образом переход. См. также

команду JNS.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|01111000\|--disp--\|

LAHF: Загрузка флагов в регистр АН

О п е р а ц и я: Загружает значение флагового регистра в регистр АН.

Данная команда обеспечивает совместимость с процессором 8080. См. также

команду SAHF. Команда LAHF заносит правый байт флагового регистра в

регистр АН в следующем виде:

SZ  _A_  P  _C \(_ обозначает неиспользуемые биты\)

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: 10011111 \(без операндов\)

LDS: Загрузка регистра сегмента данных

О п е р а ц и я: Инициализирует начальный адрес сегмента данных и

адрес смещения к переменной для обеспечения доступа к данной переменной.

Команда LDS загружает в необходимые регистры четыре байта из области

памяти, содержащей относительный адрес и сегментный адрес. Сегментный

адрес помещается в регистр DS, а относительный адрес - в любой из общих

или индексных регистров или в регистровый указатель. Следующая команда

загружает относительный адрес в регистр DI:

LDS DI,адрес\_памяти

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|11000101\|modregr/m\|

LES: Загрузка регистра дополнительного сегмента

О п е р а ц и я: Инициализирует начальный адрес дополнительного

сегмента и адрес смещения к переменной для .обеспечения доступа к данной

переменной. См. также команду LDS.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|11000100\|modregr/m\|

LOCK: Блокировка шины доступа к данным

О п е р а ц и я: Запрещает другим \(сопроцессорам одновременно

изменять элементы данных. Команда LOCK представляет собой однобайтовый

префикс, который можно кодировать непосредственно перед любой командой.

Данная операция посылает сигнал в другой процессор, запрещая использование

данных, пока не будет завершена следующая команда.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: 11110000

LODS/LODSB/LODSW: Загрузка однобайтовой или двухбайтовой строки

О п е р а ц и я: Загружает из памяти один байт в регистр AL или одно

слово в регистр AХ. Несмотря на то, что команда LODS выполняет строковую

операцию, нет смысла использовать ее с префиксом REP. Регистровая пара

DS:SI адресует в памяти байт \(для LODSB\) или слово \(для LODSW\), которые

загружаются в регистр AL или AХ соответственно. Если флаг DF равен нулю,

то операция прибавляет 1 \(для байта\) или 2 \(для слова\) к регистру SI. Если

флаг DF равен единице, то операция вычитает 1 \(для байта\) или 2 \(для

слова\) из регистра SI.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: 1010110w \(без операндов\).

LOOP: Цикл

О п е р а ц и я: Управляет выполнением группы команд определенное

число раз. До начала цикла в регистр CX должно быть -загружено число

выполняемых циклов. Команда LOOP находится в конце цикла, где она

уменьшает значение в регистре СХ. на единицу. Если значение в регистре CX

не равно нулю, то команда передает управление по адресу, указанному в

операнде \(прибавляет к регистру IP значение операнда\); в противном случае

управление передается на следующую после LOOP команду \(происходит выход из

цикла\).

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: у11100010у--disp--у

LOOPE/LOOPZ: Цикл, если равно или нуль

О п е р а ц и я: Управляет выполнением группы команд определенное

число раз или пока установлен флаг ZF \(в единичное состояние\). Команды

LOOPE/LOOPZ аналогичны команде LOOP, за исключением того, что по этим

командам цикл прекращается либо по нулевому значению в регистре CX, либо

по нулевому значению флага ZF \(ненулевое состояние\). См. также команды

LOOPNE/LOOPNZ.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|11100001\|--disp--\|

LOOPNE/LOOPNZ: Цикл, если не равно или не нуль

О п е р а ц и я: Управляет выполнением группы команд определенное

число раз или пока сброшен флаг ZF \(в нулевое состояние\)., Команды

LOOPNE/LOOPNZ аналогичны команде LOOP за исключением того, что по этим

командам цикл прекращается либо по нулевому значению в регистре CX, либо

по единичному значению флага ZF \(нулевое состояние\). См. также команды

LOOPE/LOOPZ.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|11100000\|--disp--\|

MOV: Пересылка данных

О п е р а ц и я: Пересылает один байт или одно слово между регистрами

или между регистром и памятью, а также передает непосредственное значение

в регистр или в память. Команда MOV не может передавать данные между двумя

адресами памяти \(для этой цели служит команда MOVS\). Существует семь типов

команды MOV.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д \(семь форматов\):

Регистр/память в/из регистр:

\|100010dw\|modregr/m\|

Непосредственное значение в регистр/память:

\|1100011w\|mod000r/m\|--data--\|data если w=1\|

Непосредственное значение в регистр:

\|1011wreg\|--data--\|data если w=1\|

Память в регистр AX \(AL\):

\|1010000w\|addr-low\|addr-high\|

Регистр AX \(AL\) в память:

\|1010001w\|addr-low\|addr-high\|

Регистр/память в сегментный регистр:

\|10001110\|mod0sgr/m\| \(sg - сегментный регистр\)

Сегментный регистр в регистр/память:

\|10001100\|mod0sgr/m\| \(sg - сегментный регистр\)

MOVS/MOVSB/MOVSW: Пересылка строки байт или строки слов

О п е р а ц и я: Пересылает данные между областями памяти. Команды

MOVS\(B/W\) обычно используются с префиксом REP. Команда MOVSB пересылает

любое число байтов, а команда MOVSW - любое число слов. Перед выполнением

команды регистровая пара DS:SI должна адресовать источник пересылки

\("откуда"\) а регистровая пара ES:DI - получатель пересылки \("куда"\). Если

флаг DF равен нулю, то операция пересылает данные слева направо и

увеличивает регистры SI и DI. Если флаг DF равен единице то операция

пересылает данные справа налево и уменьшает регистры SI и DI.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: 1010010w \(без операндов\).

MUL: Беззнаковое умножение

О п е р а ц и я: Умножает беззнаковое множимое \(8 или 16 бит\) на

беззнаковый множитель \(8 или 16 бит\). Левый единичный бит рассматривается

как бит данных, но не как знак минус для отрицательных чисел. Для

8-битового умножения множимое должно находиться в регистре AL, а множитель

возможен в регистре или в памяти, например MUL CL. Произведение получается

в регистре АХ. Для 16-битового умножения множимое должно находиться в

регистре АХ, а множитель возможен в регистре или в памяти, например MUL

ВХ. Произведение получается в регистровой паре DX:AX. См. также команду

IMUL.

Ф л а г и: Команда воздействует на флаги CF и OF \(флаги AF, PF, SF и

ZF не определены\).

О б ъ е к т н ы й к о д: \|1111011w\|mod100r/m\|

NEG: Изменение знака числа

О п е р а ц и я: Меняет двоичное значение из положительного в

отрицательное и из отрицательного в положительное. Команда NEG вычисляет

двоичное дополнение от указанного операнда: вычитает операнд из нуля и

прибавляет единицу. Операндом может быть байт или слово в регистре или в

памяти. См. также команду NOT. Флаги: Команда воздействует на флаги AF,

CF, OF, PF, SF и ZF.

О б ъ е к т н ы й к о д: \|1111011w\|mod011r/m\|

NOP: Нет операции

О п е р а ц и я: Применяется для удаления или вставки машинных кодов

или для задержки выполнения программы. Команда NOP выполняет операцию XCHG

АХ,АХ, которая ничего не меняет.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: 10010000 \(без операндов\)

NOT: Логическое НЕТ

О п е р а ц и я: Меняет нулевые биты на единичные и наоборот.

Операндом может быть байт или слово в регистре или в памяти. См. также

команду NEG.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: \|1111011w\|mod010r/m\|

OR: Логическое ИЛИ

О п е р а ц и я: Выполняет поразрядную дизъюнкцию \(ИЛИ\) над битами

двух операндов. Операндами являются байты или слова в регистрах или в

памяти, второй операнд может иметь непосредственное значение. Команда OR

обрабатывает операнды побитово. Если любой из проверяемых бит равен

единице, то бит в операнде 1 становится равным единице, в противном случае

бит в операнде 1 не изменяется. См. также команды AND и XOR.

Ф л а г и: Команда воздействует на флаги CF, OF, PF, SF и ZF \(флаг AF

неопределен\).

О б ъ е к т н ы й к о д \(три формата\):

Регистр/память с регистром:

\|000010dw\|modregr/m\|

Непосредственное с аккумулятором:

\|0000110w\|--data--\|data если w=1\|

Непосредственное с регистром/памятью:

\|1000000w\|mod001r/m\|--data--\|data если w=1\|

OUT: Вывод байта или слова в порт

О п е р а ц и я: Передает в выводной порт байт из регистра AL или

слово из регистра AХ. Порт кодируется как фиксированный числовой операнд

\(OUT порт\#,АХ\) или как переменная в регистре DX \(OUT DX.AX\). Процессоры

80186, 80286 и 80386 имеют, кроме того, команду OUTS \(Output String -

вывод строки\). См. также команду IN.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д \(два формата\):

Переменный порт: \|1110111w\|

Фиксированный порт:\|1110011w\|--port--\|

POP: Извлечение слова из стека

О п е р а ц и я: Передает слово \(помещенное ранее в стек\) в указанный

операнд. Регистр SP указывает на текущее слово в вершине стека. Команда

POP извлекает слово из стека и увеличивает значение в регистре SP на 2.

Существует три типа команды POP в зависимости от операнда: общий регистр,

сегментный регистр, слово в памяти. См. также команду PUSH.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д \(три формата\):

Регистр: \|01011reg\|

Сегментный регистр: \|000sg111\| \(sg-сегм.рег.\)

Регистр/память: \|10001111\|mod000r/m\|

POPA: Извлечение из стека всех общих регистров \(80188,80186,80286\)

О п е р а ц и я: Извлекает из стека восемь значений в регистры Dl, SI

BP, SP, BX, DX, CX, AX в указанной последовательности и увеличивает

регистр SP на 16. Регистры обычно записываются в стек ранее

соответствующей командой PUSHA.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: 01100001 \(без операндов\).

POPF: Извлечение флагов из стека

О п е р а ц и я: Передает биты \(помещенные ранее в стек\) во флаговый

регистр. См. также команды PUSHF и POP. Регистр SP указывает на текущее

слово в вершине стека. Команда POPF передает биты из этого слова во

флаговый регистр и увеличивает значение в регистре SP на 2. Обычно команда

PUSHF записывает значения флагов в стек, а команда POPF восстанавливает

эти флаги.

Ф л а г и: Команда воздействует на все флаги.

О б ъ е к т н ы й к о д: 10011101 \(без операндов\).

PUSH: Занесение слова в стек

О п е р а ц и я: Сохраняет значение слова \(адрес или элемент данных\)

в стеке для последующего использования. Регистр SP указывает на текущее

слово в вершине стека. Команда PUSH уменьшает значение в регистре SP на 2

и передает слово из указанного операнда в новую вершину стека. Существует

три типа команды PUSH в зависимости от операнда: общий регистр, сегментный

регистр или слово в памяти. См. также команды POP и PUSHF.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д \(три формата\):

Регистр: \|01010reg\|

Сегментный регистр: \|000sg111\| \(sg-сегм.рег.\)

Регистр/память: \|11111111\|mod110r/m\|

PUSHA: Занесение в стек всех общих регистров \(80188,80186,80286\)

О п е р а ц и я: Записывает в стек восемь значений регистров AX, CX,

DX, BX, SP, BP, SI, DI в указанной последовательности и уменьшает регистр

SP на 16. Обычно команда POPA позже восстановит эти регистры из стека.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: 01100000 \(без операндов\).

PUSHF: Занесение флагов в стек

О п е р а ц и я: Сохраняет значения флагов из флагового регистра в

стеке для последующего использования. Регистр SP указывает на текущее

слово в вершине стека. Команда PUSHF уменьшает значение в регистре SP на 2

и передает флаги в новую вершину стека. См. также команды POPF и PUSH.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: 10011100 \(без операндов\).

RCL и RCR: Циклический сдвиг влево через перенос и

циклический сдвиг вправо через перенос

О п е р а ц и я: Выполняет циклический сдвиг битов \(ротацию\) влево

или вправо через флаг CF. Данные операции могут выполняться в байте или в

слове, в регистре или в памяти. Ротация на один бит кодируется в команде

значением 1; ротация более чем на один бит требует указания регистра CL,

который содержит счетчик. Для команды RCL значение флага CF записывается в

бит 0, а. самый левый бит записывается во флаг CF; все другие биты

сдвигаются влево. Для команды RCR значение флага CF записывается в самый

левый бит, а бит 0 записывается во флаг CF; все другие биты сдвигаются

вправо. См. также команды ROL и ROR.

Ф л а г и: Команда воздействует на флаги CF и OF.

О б ъ е к т н ы й к о д: RCL: \|110100cw\|mod010r/m\|

RCR: \|110100cw\|mod011r/m\|

\(если с = 0, то сдвиг на 1;

если с = 1, то сдвиг на CL\).

REP/REPE/REPZ/REPNE/REPNZ: Повтор строковой операции

О п е р а ц и я: Повторяет строковую операцию определенное число раз.

Используется в качестве префикса повторения перед строковыми командами

CMPS, MOVS, SCAS, STOS. Счетчик повторений должен быть загружен в регистр

CX до выполнения строковой команды. Операция уменьшает регистр CX на 1 при

каждом выполнении строковой команды. Для префикса REP операция

повторяется, пока содержимое регистра CX не достигнет нуля. Для префикса

REPE/REPZ операция повторяется, пока регистр CX содержит ненулевое

значение и флаг ZF равен 1 \(нулевое состояние\). Для префикса REPNE/REPNZ

операция повторяется, пока регистр CX содержит ненулевое значение и флаг

ZF равен 0 \(ненулевое состояние\).

Ф л а г и: Определяются соответствующей строковой командой.

О б ъ е к т н ы й к о д: REP/REPNE: 11110010

REPE: 11110011

RET: Возврат из процедуры

О п е р а ц и я: Возвращает управление из процедуры, вызванной ранее

командой CALL. Команда CALL может передавать управление внутри одного

сегмента или между сегментами. Команда RET заносит слово из вершины стека

в регистр IP и увеличивает значение SP на 2. Для межсегментного возврата

команда RET, кроме того, заносит слово из новой вершины стека в регистр CS

и еще раз увеличивает значение SP на 2. Любой числовой операнд команды

\(например, RET 4\) прибавляется к указателю стека SP.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д \(четыре формата\):

Внутри сегмента: \|11000011\|

Внутри сегмента с операндом: \|11000010\|data-low\|data-high\|

Между сегментами: \|11001011\|

Между сегментами с операндом: \|11001010\|data-low\|data-high\|

ROL и ROR: Циклический сдвиг влево и циклический сдвиг вправо

О п е р а ц и я: Выполняет циклический сдвиг битов \(ротацию\) влево

или вправо. Данные операции могут выполняться в байте или в слове, в

регистре или в памяти. Ротация на один бит кодируется в команде значением

1; ротация более чем на один бит требует указания регистра CL, который

содержит счётчик. Для команды ROL самый левый бит записывается в бит 0;

все другие биты сдвигаются влево. Для команды ROR бит 0 записывается в

самый левый бит; все другие биты сдвигаются вправо. См. также команды RCL

и RCR.

Ф л а г и: Команда воздействует на флаги CF и OF.

О б ъ е к т н ы й к о д: ROL: \|110100cw\|mod000r/m\|

ROR: \|110100cw\|mod001r/m\|

\(если с = 0, то сдвиг на 1;

если с = 1, то сдвиг на CL\).

SAHF: Установка флагов из регистра АН

О п е р а ц и я: Данная команда обеспечивает совместимость с

процессором 8080 для пересылки значений флагов из регистра АН во флаговый

регистр. См. также команду LAHF. Команда SAHF пересылает определенные биты

из регистра АН во флаговый регистр в следующем виде:

SZ  _A_  P  _C \(_ обозначает неиспользуемые биты\)

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: 10011110 \(без операндов\)

SAL, SAR, SHL и SHR: Сдвиг влево или вправо

О п е р а ц и я: Выполняет сдвиг битов влево или вправо. Данные

операции могут выполняться в байте или в слове, в регистре или в памяти.

Сдвиг на один бит кодируется в команде значением 1; сдвиг более чем на

один бит требует указания регистра CL, который содержит счетчик сдвига.

Команда SAR выполняет арифметический сдвиг, который учитывает знак

сдвигаемого значения. Команды SHL и SHR выполняют логический сдвиг и

рассматривают знаковый бит как обычный бит данных. Команда SAL выполняется

аналогично команде SHL. Команды SAL и SHL сдвигают биты влево определенное

число раз и правый освобождающийся бит заполняют нулевым значением.

Команда SHR сдвигает биты вправо определенное число раз и левый

освобождающийся бит заполняет нулевым значением. Команда SAR сдвигает биты

вправо определенное число раз и левый освобождающийся бит заполняет

значением знакового бита \(0 или 1\). Во всех случаях значения битов,

выдвигаемых за разрядную сетку, теряются.

Ф л а г и: Команда воздействует на флаги CF, OF, PF, SF и ZF \(флаг AF

не определен\).

О б ъ е к т н ы й к о д: SAL/SHL: \|110100cw\|mod100r/m\|

SAR: \|110100cw\|mod111r/m\|

SHR: \|110100cw\|mod101r/m\|

\(если с = 0, то сдвиг на 1;

если с=1, то сдвиг на CL\);

SBB: Вычитание с заемом

О п е р а ц и я: Обычно используется при вычитании многословных

двоичных величин для учета единичного бита переполнения в последующей фазе

операции. Если флаг CF установлен в 1, то команда SBB сначала вычитает 1

из операнда 1. Команда SBB всегда вычитает операнд 2 из операнда 1,

аналогично команде SUB. См. также команду ADC.

Ф л а г и: Команда воздействует на флаги AF, CF, OF, PF. SF и ZF.

О б ъ е к т н ы й к о д \(три формата\):

Регистр из регистра или памяти: \|000110dw\|modregr/m\|

Непосредственное значение из регистра AX \(AL\):

\|0001110w\|--data--\|data, если w=1\|

Непосредственное значение из регистра или памяти:

\|100000sw\|mod011r/m\|--data--\|data, если sw=01\|

SCAS/SCASB/SCASW: Поиск байта или слова в строке

О п е р а ц и я: Выполняет поиск определенного байта или слова в

строке. Для команды SCASB необходимое значение загружается в регистр AL, а

для команды SCASW - в регистр AX. Регистровая пара ES:DI указывает на

строку в памяти, которая должна быть сканирована. Данные команды обычно

используются с префиксом REPE или REPNE. Если флаг DF равен нулю, то

операция сканирует память слева направо и увеличивает регистр DI. Если

флаг DF равен единице, то операция сканирует память справа налево и

уменьшает регистр DI.

Ф л а г и: Команда воздействует на флаги AF, CF, OF, PF, SF и ZF.

О б ъ е к т н ы й к о д: 1010111w \(без операндов\).

STC: Установка флага переноса

О п е р а ц и я: Устанавливает значение флага CF в 1. См. также

команду STD.

Ф л а г и: Команда воздействует на флаг CF \(устанавливается в 1\).

О б ъ е к т н ы й к о д: 11111001 \(без операндов\).

STD: Установка флага направления

О п е р а ц и я: Устанавливает значение флага направления в 1. В

результате строковые операции, такие, как MOVS или CMPS, обрабатывают

данные справа налево. См. также CLD.

Ф л а г и: Команда воздействует на флаг DF \(устанавливается в 1\).

О б ъ е к т н ы й к о д: 11111101 \(без операндов\).

STI: Установка флага прерывания

О п е р а ц и я: Разрешает маскируемые внешние прерывания после

выполнения следующей команды и устанавливает значения флага прерывания IF

в 1. См. также команду CLI.

Ф л а г и: Команда воздействует на флаг IF \(устанавливается в 1\).

О б ъ е к т н ы й к о д: 11111011 \(без операндов\).

STOS/STOSB/STOSW: Запись однобайтовой или двухбайтовой строки

О п е р а ц и я: Сохраняет байт или слово в памяти. При использовании

префикса REP операция дублирует значение байта или слова определенное

число раз, что делает ее удобной для очистки областей памяти. Для команды

STOSB необходимый байт загружается в регистр AL, а для команды STOSW

необходимое слово загружается в регистр АХ. Регистровая пара ES:DI

указывает область памяти, куда должен быть записан байт или слово. Если

флаг DF равен нулю, то операция записывает в память слева направо и

увеличивает регистр DI. Если флаг DF равен единице, то операция записывает

в память справа налево и уменьшает значение в регистре DI.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: 1010101w \(без операндов\).

SUB: Вычитание двоичных чисел

О п е р а ц и я: Вычитает байт или слово в регистре, памяти или

непосредственное значение из регистра; или вычитает байт или слово в

регистре или непосредственное значение из памяти. См. также команду SBB.

Ф л а г и: Команда воздействует на флаги AF, CF, OF, PF, SF и ZF.

О б ъ е к т н ы й к о д \(три формата\):

Регистр из регистра или памяти:

\|001010dw\|modregr/m\|

Непосредственное значение из регистра АХ \(AL\):

\|0010110w\|--data--\|data, если w=1\|

Непосредственное значение из регистра или памяти:

\|100000sw\|mod101r/m\|--data--\|data, если sw=01\|

TEST: Проверка битов

О п е р а ц и я: Команда выполняет проверку байта или слова на

определенную битовую комбинацию. Команда TEST действует аналогично команде

AND, но не изменяет результирующий операнд. Операнды могут иметь

однобайтовые или двухбайтовые значения. Второй операнд может иметь

непосредственное значение. Команда выставляет флаги в соответствии с

логической функцией И.

Ф л а г и: Команда воздействует на флаги CF, OF, PF, SF и ZF \(флаг AF

не определен\).

О б ъ е к т н ы й к о д \(три формата\):

Регистр или память И регистр:

\|1000010w\|modregr/m\|

Непосредственное значение И регистр АХ \(AL\):

\|1010100w\|--data--\|data, если w=1\|

Непосредственное значение И регистр или память:

y1111011w\|mod000r/m\|--data--\|data, если w=1\|

WAIT: Установка процессора в состояние ожидания

О п е р а ц и я: Позволяет процессору оставаться в состоянии

ожидания, пока не произойдет внешнее прерывание. Данная операция

необходима для обеспечения синхронизации процессора с внешним устройством

или с сопроцессором. Процессор ожидает, пока внешнее устройство \(или

сопроцессор\) не закончит выполнение операции и на входной линии TEST не

появится сигнал \(активный уровень\).

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: 10011011

XCHG: Перестановка

О п е р а ц и я: Переставляет два байта или два слова между двумя

регистрами \(например, XCHG AH,BL\) или между регистром и памятью \(например,

XCHG CX,word\).

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д \(два формата\):

Регистр и аккумулятор: \|10010reg\|

Регистр/память и регистр: \|1000011w\|modregr/m\|

XLAT: Перекодировка

О п е р а ц и я: Транслирует байты в другой формат, например при

переводе нижнего регистра в верхний или при перекодировке ASCII-кода в

EBCDIC-код. Для выполнения данной команды необходимо определить таблицу

преобразования байт и загрузить ее адрес в регистр ВХ. Регистр AL должен

содержать байт, который будет преобразован с помощью команды XLAT.

Операция использует значение в регистре AL как смещение в таблице,

выбирает байт по этому смещению и помещает его в регистр AL.

Ф л а г и: Не меняются.

О б ъ е к т н ы й к о д: 11010111 \(без операндов\).

XOR: Исключающее ИЛИ

О п е р а ц и я: Выполняет логическую операцию исключающего ИЛИ над

битами двух операндов. Операндами являются байты или слова в регистрах или

в памяти, второй операнд может иметь непосредственное значение. Команда

XOR обрабатывает операнды побитово. Если проверяемые биты одинаковы, то

команда XOR устанавливает бит в операнде 1 равным нулю, если биты

различны, то бит в операнде 1 устанавливается равным единице. См. также

команды AND и OR.

Ф л а г и: Команда воздействует на флаги CF, OF, PF, SF и ZF \(флаг AF

неопределен\).

О б ъ е к т н ы й к о д \(три формата\):

Регистр/память с регистром:

\|001100dw\|modregr/m\|

Непосредственное с регистром AX \(AL\):

\|0011010w\|--data--\|data если w=1\|

Непосредственное с регистром/памятью:

\|1000000w\|mod110r/m\|--data--\|data если w=1\|

ПРИЛОЖЕНИЯ

ПРИЛОЖЕНИЕ 1: Коды ASCII-символов

Ниже представлены первые 128 символов ASCII-кода. В руководстве по

языку BASIC приведены остальные 128 символов. На помним, что шест.20

представляет стандартный символ пробела.

Таблица A-1. Набор ASCII символов

Дес Шест Симв Дес Шест Симв Дес Шест Симв Дес Шест Симв

000 00h Нуль 032 20h sp 064 40h @ 096 60h \`

001 01h Начало заголовка 033 21h ! 065 41h A 097 61h a

002 02h Начало текста 034 22h " 066 42h B 098 62h b

003 03h Конец текста 035 23h \# 067 43h C 099 63h c

004 04h Конец передачи 036 24h $ 068 44h D 100 64h d

005 05h КТМ 037 25h % 069 45h E 101 65h e

006 06h Да 038 26h & 070 46h F 102 66h f

007 07h Звонок 039 27h ' 071 47h G 103 67h g

008 08h Возврат на шаг 040 28h \( 072 48h H 104 68h h

009 09h Гориз.табуляция 041 29h \) 073 49h I 105 69h i

010 0Ah Перевод строки 042 2Ah \* 074 4Ah J 106 6Ah j

011 0Bh Верт.табуляция 043 2Bh + 075 4Bh K 107 6Bh k

012 0Ch Перевод страницы 044 2Ch , 076 4Ch L 108 6Ch l

013 0Dh Возврат каретки 045 2Dh - 077 4Dh M 109 6Dh m

014 0Eh Shift out 046 2Eh . 078 4Eh N 110 6Eh n

015 0Fh Shift in 047 2Fh / 079 4Fh O 111 6Fh o

016 10h Data line esc 048 30h 0 080 50h P 112 70h p

017 11h Управление 1 049 31h 1 081 51h Q 113 71h q

018 12h Управление 2 050 32h 2 082 52h R 114 72h r

019 13h Управление 3 051 33h 3 083 53h S 115 73h s

020 14h Управление 4 052 34h 4 084 54h T 116 74h t

021 15h Нет 053 35h 5 085 55h U 117 75h u

022 16h Синхронизация 054 36h 6 086 56h V 118 76h v

023 17h Конец блока 055 37h 7 087 57h W 119 77h w

024 18h Анулирование 056 38h 8 088 58h X 120 78h x

025 19h End of medium 057 39h 9 089 59h Y 121 79h y

026 1Ah Замена 058 3Ah : 090 5Ah Z 122 7Ah z

027 1Bh Escape 059 3Bh ; 091 5Bh \[ 123 7Bh {

028 1Ch Раздел.файла 060 3Ch &lt; 092 5Ch  124 7Ch \|

029 1Dh Раздел.группы 061 3Dh = 093 5Dh 125 7Dh }

030 1Eh Раздел.записи 062 3Eh &gt; 094 5Eh ^ 126 7Eh ~

031 1Fh Раздел.единицы 063 3Fh ? 095 5Fh \_ 127 7Fh Забой

ПРИЛОЖЕНИЕ 2: Шестнадцатерично-десятичные преобразования

В данном приложении представлены приемы преобразования между

шестнадцатеричным и десятичным форматами. В первом разделе показан пример

преобразования шест. A7B8 в десятичное 42936, а во втором - 42936 обратно

в шест. A7B8.

Преобразование шестнадцатеричного формата в десятичный

Для перевода шест. A7B8 в десятичное число необходимо

последовательно, начиная с самой левой шест. цифры \(A\), умножать на 16 и

складывать со следующей цифрой. Так как операции выполняются в десятичном

формате, то шест. числа от A до F необходимо преобразовать в десятичные от

10 до 15.

Первая цифра: A \(10\) 10

Умножить на 16 х16

160

Прибавить следующую цифру, 7 +7

167

Умножить на 16 х16

2672

Прибавить следующую цифру, B \(11\) +11

2683

Умножить на 16 х16

42928

Прибавить следующую цифру, 8 +8

Десятичное значение 42936

Можно использовать также таблицу преобразования. Для шест. числа A7B8

представим правую цифру \(8\) как позицию 1, следующую влево цифру \(B\) как

позицию 2, следующую цифру \(7\) как позицию 3 и самую левую цифру \(A\) как

позицию 4. Из таблицы B-1 выберем значения для каждой шест. цифры:

Для позиции 1 \(8\), столбец 1 8

Для позиции 1 \(8\), столбец 1 176

Для позиции 1 \(8\), столбец 1 1792

Для позиции 1 \(8\), столбец 1 40960

Десятичное значение 42936

Преобразование десятичного формата в шестнадцатеричный

Для преобразования десятичного числа 42936 в шестнадцатеричный формат

необходимо сначала исходное число 42936 разделить на 16; число,

получившееся в остатке, \(6\) является младшей шестнадцатеричной цифрой.

Затем полученное частное необходимо снова разделить на 16 и полученный

остаток \(11 или B\) дает следующую влево шестнадцатеричную цифру. Продолжая

таким образом деления до тех пор, пока в частном не получится 0, получим

из остатков все необходимые шестнадцатеричные цифры.

Частное Остаток Шест.

42936 / 16 2683 8 8 \(младшая цифра\)

2683 / 16 167 11 B

167 / 16 10 7 7

10 / 16 0 10 A \(старшая цифра\)

Для преобразования чисел из десятичного формата в шестнадцатеричный

можно также воспользоваться таблицей B-1. Для десятичного числа 42936

необходимо найти в таблице число равное или ближайшее меньшее исходному, и

записать соответствующую шестнадцатеричную цифру и ее позицию. Затем

следует вычесть найденное десятичное число из 42936 и с полученной

разностью проделать проделать ту же операцию:

Дес. Шест.

Исходное десятичное число 42936

Вычесть ближайшее меньшее 40960 A000

Разность 1976

Вычесть ближайшее меньшее 1792 700

Разность 184

Вычесть ближайшее меньшее 176 B0

Разность 8 8

Результирующее шест. число A7B8

Таблица B-1. Шестнадцатерично-десятичные преобразования

┌────────────┬───────────┬──────────┬────────┬───────┬──────┬─────┬─────┐

│Ш │Ш │Ш │Ш │Ш │Ш │Ш │Ш │

│Е │Е │Е │Е │Е │Е │Е │Е │

│С │С │С │С │С │С │С │С │

│Т ДЕС │Т ДЕС │Т ДЕС │Т ДЕС │Т ДЕС│Т ДЕС│Т ДЕС│Т ДЕС│

├────────────┼───────────┼──────────┼────────┼───────┼──────┼─────┼─────┤

│0 0│0 0│0 0│0 0│0 0│0 0│0 0│0 0│

│1 268435456│1 16777216│1 1048576│1 65536│1 4096│1 256│1 16│1 1│

│2 536870912│2 33554432│2 2097152│2 131072│2 8192│2 512│2 32│2 2│

│3 805306368│3 50331648│3 3145728│3 196608│3 12288│3 768│3 48│3 3│

│4 1073741824│4 67108864│4 4194304│4 262144│4 16384│4 1024│4 64│4 4│

│5 1342177280│5 83886080│5 5242880│5 327680│5 20480│5 1280│5 80│5 5│

│6 1610612736│6 100663296│6 6291456│6 393216│6 24576│6 1536│6 96│6 6│

│7 1879048192│7 117440512│7 7340032│7 458752│7 28672│7 1792│7 112│7 7│

│8 2147483648│8 134217728│8 8388608│8 524288│8 32768│8 2048│8 128│8 8│

│9 2415919104│9 150994944│9 9437184│9 589824│9 36864│9 2304│9 144│9 9│

│A 2684354560│A 167772160│A 10485760│A 655360│A 40960│A 2560│A 160│A 10│

│B 2952790016│B 184549376│B 11534336│B 720896│B 45056│B 2816│B 176│B 11│

│C 3221225472│C 201326592│C 12582912│C 786432│C 49152│C 3072│C 192│C 12│

│D 3489660928│D 218103808│D 13631488│D 851968│D 53248│D 3328│D 208│D 13│

│E 3758096384│E 234881024│E 14680064│E 917504│E 57344│E 3584│E 224│E 14│

│F 4026531840│F 251658240│F 15728640│F 983040│F 61440│F 3840│F 240│F 15│

├────────────┼───────────┼──────────┼────────┼───────┼──────┼─────┼─────┤

│ 8 │ 7 │ 6 │ 5 │ 4 │ 3 │ 2 │ 1 │

└────────────┴───────────┴──────────┴────────┴───────┴──────┴─────┴─────┘

Шестнадцатиpичные позиции

ПРИЛОЖЕНИЕ 3: Зарезервированные слова

Большинство из следующих зарезервированных слов при использовании их

для определении элементов данных могут привести к ошибкам ассемблирования

\(в ряде случаев - к весьма грубым\):

Имена регистров

AH BH CH DH CS SS BP

AL BL CL DL DS SI SP

AX BX CX DX ES DI

Мнемокоды

AAA DIV JLE JS OR SBB

AAD ESC JMP JZ OUT SCAS

AAM HLT JNA LAHF POP SHL

AAS IDIV JNAE LDS POPF SHR

ADC IMUL JNB LEA PUSH STC

ADD IN JNBE LES PUSHF STD

AND INC JNE LOCK RCL STI

CALL INT JNG LODS RCR STOS

CBW INTO JNGE LOOP REP SUB

CLC IRET JNL LOOPE REPE TEST

CLD JA JNLE LOOPNE REPNE WAIT

CLI JAE JNO LOOPNZ REPNZ XCHG

CMC JB JNP LOOPZ REPZ XLAT

CMP JBE JNS MOV RET XOR

CMPS JCXZ JNZ MOVS ROL

CWD JE JO MUL ROR

DAA JG JP NEG SAHF

DAS JGE JPE NOP SAL

DEC JL JPO NOT SAR

Директивы ассемблера

ASSUME END EXTRN IFNB LOCAL PURGE

COMMENT ENDIF GROUP IFNDEF MACRO RECORD

DB ENDM IF IF1 NAME REPT

DD ENDP IFB IF2 ORG SEGMENT

DQ ENDS IFDEF INCLUDE OUT STRUC

DT EQU IFDIF IRP PAGE SUBTTL

DW EVEN IFE IRPC PROC TITLE

ELSE EXITM IFIDN LABEL PUBLIC

Прочие элементы языка

BYTE FAR LENGTH MOD PRT THIS

COMMENT GE LINE NE SEG TYPE

CON GT LT NEAR SHORT WIDTH

DUP HIGH LOW NOTHING SIZE WORD

EQ LE MASK OFFSET STACK

ПРИЛОЖЕНИЕ 4: РЕЖИМЫ АССЕМБЛИРОВАНИЯ И КОМПОНОВКИ

Ассемблирование программы

На дискете с ассемблерным пакетом имеются две версии ассемблера:

ASM.EXE - сокращенная версия, в которой отсутствуют некоторые возможности,

и MASM.EXE - полная версия, имеющая все возможности и являющаяся

предпочтительной. Для ассемблирования вставьте ассемблерную дискету в

дисковод А, а дискету с исходной программой - в дисковод В. Кто имеет

винчестер или RAM-диск \(виртуальный диск в памяти\), могут в следующих

примерах заменить соответствующие номера дисководов. Введите команды MASM

\(или ASM\), что приведет к загрузке программы ассемблера с диска в память.

На экране появится:

source filename \[.ASM\]:

object filename \[filename.OBJ\]:

source listing \[NUL.LST\]:

cross-reference \[NUL.CRF\]:

Курсор при этом расположится в конце первой строки, где необходимо

указать имя файла. Введите номер дисковода \(если он не определен по

умолчанию\) и имя файла. Не следует набирать тип файла ASM - ассемблер

подразумевает это. Во втором запросе предполагается аналогичное имя файла

\(но можно его заменить\). Если необходимо, введите номер дисковода. Третий

запрос предполагает, что листинг ассемблирования программы не требуется.

Последний запрос предполагает, что листинг перекрестных ссылок не

требуется. Для получения листинга на дисководе В введите В:.

Если вы хотите оставить значения по умолчанию, то в трех последних

запросах просто нажмите Return. Ниже приведен пример запросов и ответов, в

результате которых ассемблер должен создать OBJ-, LST- и CRF-файлы на

дисководе В:

source filename \[.ASM\]:B:ASMPROG \[Return\]

object filename \[filename.OBJ\]:B: \[Return\]

source listing \[NUL.LST\]:B: \[Return\]

cross-reference \[NUL.CRF\]:B: \[Return\]

Альтернативный вариант вызова ассемблера:

MASM B:name.ASM,B:name.OBJ,B:name.LST,B:name.CRF

В следующей команде используются значения по умолчанию:

MASM B:filename,B:,B:,В:;

* первый параметр B:filename идентифицирует исходную программу,

которая должна быть ассемблирована;

* второй параметр В: указывает ассемблеру на необходимость

записать объектный модуль на дисковод В под именем filename.OBJ;

* третий параметр В: указывает ассемблеру на необходимость

записать листинг ассемблирования на дисковод В под именем

filename.LST;

* четвертый параметр В: приводит к генерации файла перекрестных

ссылок под именем filename.CRF;

* Точка с запятой в конце команды указывает ассемблеру на

необходимость игнорировать любые последующие параметры. Хотя в

приведенном примере таких параметров нет, кодирование точки с запятой

является хорошим правилом для других вариантов команды.

При наличии ошибок ассемблирования программа ASM выдает только коды

ошибок, которые объяснены в руководстве по Ассемблеру, в то время как

программа MASM выдает и коды ошибок, и пояснения к ним. Всего имеется

около 100 сообщений об ошибках.

Режимы ассемблирования включают следующие:

MASM /A организовать исходные сегменты в алфавитном порядке;

MASM /D генерировать LST-файл в обоих проходах ассемблирования;

MASM /E ассемблировать команды для сопроцессора 8087 и генерировать

связи для языка ФОРТРАН и пакета эмуляции языка ПАСКАЛЬ;

MASM /N отменить генерацию таблицы идентификаторов;

MASM /R ассемблировать команды для сопроцессора 8087 \(аналогично /E\);

MASM /S сохранить исходные сегменты в оригинальной последовательности.

Файл перекрестных ссылок

Генерируемый в ходе ассемблирования CRF-файл может использоваться для

создания листинга перекрестных ссылок на метки, идентификаторы и

переменные в программе. Для получения CRF-фала необходимо на четвертый

запрос ассемблера ответить, например. В:, полагая, что файл должен быть

создан на диске В:

cross-reference \[NUL.CRF\]:B: \[Return\]

Для преобразования полученного CRF-файла в удобно отсортированную

таблицу перекрестных ссылок используется программа CREF, имеющаяся на

ассемблерном диске. Введите команду CREF; на экране появится два запроса:

Cref filename \[.CRF\]:

List filename \[cross-ref.REF\]:

На первый запрос введите имя CRF-файла, например B:ASMPROG. На второй

запрос можно ввести только номер дисковода и получить имя по умолчанию.

Такой выбор приведет к преобразованию CRF-файла в файл перекрестных ссылок

по имени filename.REF на дисководе В. Можно также кодировать всю команду в

одной строке, например:

CREF В: filename. CRF, CON иди CREF B:filename.CRF,B:

В первом примере файл перекрестных ссылок выводится на экран. Второй

пример записывает файл по имени filename.REF на диск В.

Компоновка программ

Для компоновки ЕХЕ-программы вставьте дискету DOS в дисковод А, а

дискету с программой - в дисковод В. Те, кто имеют винчестер или RAM-диск

\(виртуальный диск в памяти\), могут в следующих примерах заменить

соответствующие номера дисководов. Простейший способ запуска компоновщика

представляет ввод команды LINK, что приводит к загрузке компоновщика с

диска в память. На экране появятся следующие запросы:

Object Modules \[.OBJ\]:

Run File \[d:filename.ЕХЕ\]:

List File \[NUL.MAP\]:

Libraries \[.LIB\]:

Курсор при этом расположится в конце первой строки, где необходимо

указать имя файла. Введите номер дисковода \(если он не определен по

умолчанию\) и имя файла. Не следует набирать тип файла OBJ - компоновщик

подразумевает это. Во втором запросе предполагается аналогичное имя файла

\(но можно его заменить\). Если необходимо, введите номер дисковода. Третий

запрос предполагает, что листинг компоновки программы не требуется.

Последний запрос имеет отношение к библиотечным средствам DOS.

Если вы хотите оставить значения по умолчанию, то в трех последних

запросах просто нажмите Return. Ниже приведен пример запросов и ответов, в

результате которых компоновщик должен создать файлы ЕХЕ и CON:

Object Modules \[.OBJ\]:B:ASMPROG \[return\]

Run File \[d:filename.ЕХЕ\]:В: \[return\]

List File \[NUL.MAP\]:CON \[return\]

Libraries \[.LIB\]: \[return\]

Ответ CON приводит к выводу карты компоновки на экран для проверки на

наличие сообщений об ошибках. Команду LINK можно сформировать также

следующим образом:

LINK B:ASMPROG,В:,CON

Описание остальных режимов компоновщика LINK можно найти в

руководстве no DOS.

Программа ЕХЕ2ВIN

Программа EXE2BIN.COM в операционной системе DOS используется для

преобразования ЕХЕ-модулей в СОМ-модули, при этом полагается, что

программы подготовлены в соответствии с требованиями для СОМ-модулей. Для

запуска программы EXE2BIN вставьте дискету DOS в дисковод А, а дискету с

ЕХЕ-файлом - в дисковод В. Для винчестерского диска следует использовать

дисковод С. Введите следующую команду:

EXE2BIN B:filename,B:filename.COM

Первым операндом является имя ЕХЕ-файла, которое вводится без

указания типа. Второй операнд представляет собой имя СОМ-файла; здесь

можно изменить имя программы, но обязательно следует указывать тип СОМ.

После того как преобразование будет выполнено, можно удалить файлы OBJ и

ЕХЕ.

Ответы на некоторые вопросы

1.1. а\) 01001101; в\) 00111111.

1.2. а\) 0101; в\) 10101.

1.3. а\) 00100010; в\) 00100000.

1.4. а\) 11101101; в\) 11000110.

1.5. а\) 00111000; в\) 10000000.

1.6. а\) 51; в\) 5D.

1.7. а\) 23С8; в\) 8000.

1.8. а\) 13; в\) 59; д\) FFF.

1.9. а\) Стек, данные и код; в\) параграф.

1.l0. a\) AX, BX, CX, DX, Dl, SI; в\) AX и DX; д\) флаги.

1.11.a\) ROM \(постоянная память выполняет процедуры начальной загрузки и

управляет операциями ввода-вывода.

б\) RAM \(оперативная память\) представляет собой область, где находятся

программы и данные при выполнении.

2.1. а\) В82946.

2.2. Е CS:101 54.

2.3. a\) MOV AX, 3004

ADD AX,3000

RET

в\) R и IP устанавливают IP в 0.

2.4. Произведение равно 0612Н.

2.6. Использовать команду N для указания имени программы \(например, СОМ\),

установить длину программы в регистре CX и с помощью команды W

записать программу.

3.1. TITLE и PAGE.

3.2. а\), б\) и в\) корректны; г\) неверно, так как начинается с цифры;

д\) корректно только при ссылке на регистр AX.

3.4. a\) END; в\) ENDS.

3.6. RET является командой, которая обеспечивает возврат в операционную

систему; END является директивой, которая указывает ассемблеру, что в

тексте более нет команд для ассемблирования.

3.7. ASSUME CS:CDSEG,DS:DATSEG,SS:STKSEG.

3.8. PUSH DS

SUB AX, AX

PUSH AX

4.1. а\) Ввести команду MASM и ответить на запросы: В:TEMPY В:, В: и В:

4.2. a\) DEBUG B:TEMPY.EXE; б\) B:TEMPY

4.3. а\) Резервная копия исходного файла;

в\) файл листинга ассемблирования с исходным и объектным кодом;

д\) файл объектного кода;

ж\) карта компоновки.

4.4. MOV AX,DATSEG

MOV DS,AX

4.5. MOV AL,30H

SHL AL,1

MOV BL,18H

MUL BL

4.6. Сегмент данных должен выглядеть следующим образом:

FLDA OB 28H

FLDB DB 14H

FLDC DW ?

5.1. а\) 2; в\) 10; д\) 8.

5.2. CONAME DB 'RGB Electronics'

5.3. a\) FLDA DD 73H

в\) FLDC DW ?

д\) FLDE DW 16, 19, 20, 27, 30

5.4. a\) ASCII 3236; б\) 1AH.

5.5. а\) 26; в\) ЗА732500.

5.6. a\) MOV AX,320

в\) ADD BX,40H

д\) SHL FLDB,1 \(или SAL\)

6.1. 64 К.

6.3. Это использует старшую область COM-программы или при недостатке

памяти - старшие адреса оперативной памяти.

6.4. EXE2BIN SAMPLE,SAMPLE.COM.

7.1. +127 и -128. Операнд представляет собой однобайтовое значение от 00Н

до 7FH \(от 0 до + 127\) и от 80Н до 0FFH \(от -128 до -1\).

7.2. а\) 62В; в\) 5ЕА \(преобразует С6 в двоичное дополнение\).

7.3. Приводим одно из многих возможных решений:

MOV AX,00

MOV BX,01

MOV CX,12

MOV DX,00

В20:

ADD AX,BX ;Номер в AX

MOV BX,DX

MOV DX,AX

LOOP B20

7.4. а\) CMP DX,CX в\) JCXZ адрес д\) CMP BX,AX

JA адрес или CMP CX,0 JLE или JNG

JZ адрес

7.5. a\) OF \(1\); в\) ZF \(1\); д\) DF \(1\)

7.7. Первая \(основная\) процедура PROC должна иметь атрибут FAR, так как ее

вызов и выполнение происходят из операционной системы. Атрибут NEAR

указывает на то, что адрес процедуры находится внутри конкретной

программы \(т.е. в пределах одного сегмента ассемблерного модуля\).

7.9. Три \(по одному на каждый вызов CALL\).

7.10.а\) 1001 1010; в\) 1111 1011; д\) 0001 1100.

7.12.а\) 01011100 11011100; в\) 11001101 11001000.

8.1. Строка = 18Н, столбец = 27Н.

8.3. MOV AX,0600H ;3апрос

MOV BH,07 ; функции

MOV CX,OCOOH ; очистки

MOV DX,164FH ; экрана

INT 10Н

8.4. а\) Вызов базовой функции DOS:

MSSGE DB 'What Is the date \(mm/dd/yy\)?',07H,'$'

MOV AH,09 ;Запрос функции

MOV DX,MSSGE ;вывода сообщения

INT 21H

8.5. а\) Вызов базовой функции DOS:

DATEPAR LABEL BYTE

MAXLEN DB 9 ;Длина области ввода

ACTLEN DB ?

DATEFLD DB 9 DUP\(' '\)

DB '$'

MOV AH,0AH ;Запрос функции

LEA DX,DATEPAR ; ввода

INT 21H

9.1. a\) 1000 0001; в\) 0111 1000.

9.2. a\) MOV АН,00 ;Запрос функции установки режима

MOV AL,02 ; 80х25 BW

INT 10Н

в\) MOV AН,060AН ;3апрос прокрутки на 10 строк

MOV BH,07 ;Нормальный видеоатрибут

MOV CX,0000 ;Полный экран

MOV DX,184FH

INT 10Н

9.3. а\) 48; в\) 47.

9.5. Использовать команду INT 10Н для ввода и проверить скэнкод.

10.1. Восемь цветов для фона и 16 цветов для текста.

10.2. а\) 1011 0101; в\) 1000 1100.

10.3. Низкое разрешение: четыре бита на пиксел дает 16 цветов.

Среднее разрешение: два бита на пиксел дает 4 цвета.

Высокое разрешение: один бит на пиксел дает 2 "цвета" \(BW -

черно-белое изображение\).

10.4. MOV AH,09 ;Функция вывода

MOV AL,04 ;Символ

MOV BH,00 ;Страница \#0

MOV BL,01011010В ;Светло-зеленый на сиреневом

MOV CX,05 ;Повторение 5 раз

INT 10Н

10.6. Сначала установить графический режим, а затем, используя

INT 10Н \(AH=0BH\),

установить цвет фона.

10.7. Сначала установить графический режим.

MOV AH,0DH ;Прочитать точку

MOV CX,13 ;Столбец

MOV DX,12 ;Строка

INT 10Н

11.1. а\) JCXZ lаbеl2

label1: MOV AX,\[SI\]

MOV \[DI\],AX

INC DI

INC DI

INC SI

INC SI

LOOP label1

label2: ...

11.2. Установить флаг направления DF для пересылки справа налево. Для

команды MOVSB начальная установка на адреса NAME1 + 9 и NAME2 + 9.

Для команды MOVSW начальная установка на адреса NAME1 + 8 и

NAME2 + 8. Подпрограмма по метке H10SCAS может использовать

MOV AX,'mb'

и с помощью команды SCASW выполнить сканирование.

11.3. a\) CLD ;Пересылка слева направо

LEA SI,CONAME ;Инициализация

LEA DI,PRLINE ; для пересылки

MOV CX,20 ; 20 байт

REP MOVSB

в\) CLD ;Пересылка слева направо

LEA SI,CONAME+2 ;Начать с 3-го

LODSW ;Загрузить два байта

д\) CLD ;Пересылка слева направо

MOV CX,20 ;20 байт

LEA SI,CONAME ;Инициализация

LEA DI,PRLINE ;адресов

REPE CMPSB ;Сравнение

11.4. Одно из решений:

H10SCAS PROC NEAR

CLD ;Пересылка слева направо

MOV CX,10 ;10 байт

LEA DI,NAME1 ;Инициализация адреса

MOV AL,'e' ; и символа для поиска

Н20:

REPNE SCASB ;Сканирование

JNE H3Q ;Символ найден?

CMP BYTE PTR\[DI\],'r' ; Да - следующий

JNE Н20 ; байт равен r?

MOV AH, 03

Н30: RET

H10SCAS ENDP

11.5. PATTERN DB 0ЗН,04Н,05Н,0В4Н

DISPLAY DB 80 DUP\(' '\),'$'

CLD ;Пересылка слева направо

LEA SI,PATTERN ;Инициализация

LEA DI,DISPLAY ; адресов

MOV CX,20 ;20 байт

REP MOVSW ;Переслать образец

Затем можно использовать команду INT 21 Н для вывода на экран

значения из области DISPLAY.

12.1.a\) MOV AX,DATAY

ADD AX,DATAX

MOV DATAY,AX

б\) См. рис.12.2 \(многословное сложение\).

12.2.Команда STC устанавливает флаг CF.Сумма равна 0148Н плюс 0237Н плюс 1

12.3.a\) MOV AX,DATAX

MUL DATAY

б\) См. рис.12.4 для умножения двойного слова на слово.

12.5. a\) MOV AX,DATAX

MOV BL,25

DIV BL

13.1. а\) Команда ADD дает результат 6СН, а команда AAA - 0102Н.

в\) Команда SUB дает результат 02Н, а команда AAS не имеет эффекта.

13.2. LEA SI,UNPAK ;Инициализация адреса

MOV CX,04 ; и счетчика циклов

В20:

OR \[SI\],ЗОН ;Включить тройку кода ASCII

INC SI ;Перейти к следующему байту

LOOP B20 ;Циклить 4 раза

13.3. В качестве примера см.рис.13.2, отличие - CX = 03.

13.4. В качестве примера см.рис.13.3, отличие - CX = 03.

13.5. а\) Преобразование числа в ASCII-коде в двоичное представление:

Десятичные Шестнадцатиричные

8х1 = 8 8

2 х 10 = 20 14

3 х 100 = 300 12С

6 х 1000 = 6000 1770

4 х 10000 = 40000 9С40

B4F8

14.1. WKDAYS DB 'Sunday...'

DB 'Monday... '

DB 'Tuesday..'

14.2. DAYNO DB ?

DAYNAM DB 9 DUP\(?\)

NINE DB 9

LEA SI,WKDAYS ;Загрузить адрес таблицы

SUB АН,АН ;Очистить АН

MOV AL,DAYNO ;Загрузить день недели

DEC AL ;-1

MUL NINE ;Получить смещение

ADD SI,AX ;Плюс адрес таблицы

MOV CX,09 ;Девять символов

LEA DI,DAYNAM ;Адрес пересылки

REP MOVSB ;Переслать 9 символов

14.3. a\) ITEMNO DB '06','10','14','21','24'

в\) ITPRICE DW 9395,8225,9067,8580,1385

14.4. Возможная организация представлена в следующих процедурах:

Основной цикл Вызов процедур

В1OREAD Выдает на текст запроса и вводит номер элемента.

C10SRCH Выполняет поиск в таблице и выдает сообщение об ошибке.

D10MOVE Выделяет описание и цену из таблицы.

E10CONV Преобразует количество из кода ASCII в двоичное представление.

F10CALC Вычисляет стоимость \(количество х цена\).

G10CONV Преобр. стоимость из двоичн. представления в симв. \(код ASCII\).

K10DISP Выводит описание и стоимость на экран.

14.5. SORTAB DB 5 DUP\(9 DUP\(?\)\)

LEA SI,ITDESC ;Инициализация

LEA 01,SORTAB ; адреса таблицы

MOV CX,45 ; и числа символов

CLD ;Направление слева направо

REP MOVSB ;Переслать таблицу

Приведенная подпрограмма пересылает таблицу. Для сортировки таблицы

см. рис.14.6.

15.1. 512.

15.3. В каталоге первый байт имени файла должен быть установлен в Е5.

15.5. Первый байт таблицы FAT содержит F8.

15.6. а\) Позиции 28...31 в каталоге;

б\) шестнадцатиричное число В4А записывается как 4А0В.

16.1. Все функции включают INT 21 Н: а\) 16Н; в\) 15Н; д\) 14Н.

16.2. а\) 4; б\) 108 \(9 секторов х 3 дорожки х 4 записи на дорожке\);

в\) одно обращение на сектор, т.е. всего 27.

16.3.Используйте рис.16.1 в качестве примера для создания файла и рис.13.6

для преобразования чисел из ASCII-кода в двоичное представление.

16.4. Используйте рис.16.2 в качестве примера для чтения файла и рис.13.6

для преобразования чисел из двоичного представления в ASCII-код.

16.5.а\) Блок 0, запись 44; в\) блок 1, запись 21.

16.6.Десятичное число 2652 равно шестнадцатиричному 0А5С, что записывается

как 5С0А0000.

16.7. Функции включают INT 21Н: а\) 22Н; в\) 28Н.

16.8. Поле FCBFLSZ содержит размер файла в байтах \(произведение числа

записей на длину записи\), поле FCBRCSZ содержит длину записей.

Разделите FCBFLSZ \(четыре байта в регистровой паре DX:AX\) на FCBRCSZ

\(два байта\).

16.9. См. рис.16.4 в качестве примера для чтения блока.

16.10. В гл.13 показано, как преобразовать числа в ASCII-коде в двоичное

представление.

16.11. Можно использовать рис.16.3 в качестве примера для прямого чтения и

рис.13.6 для преобразования чисел из ASCII-кода в двоичное

представление.

17.1. 01 и 06.

17.3.а\) MOV AH,3CH ;Ф-ция создания файла

MOV CX,00 ;Нормальный атрибут

LEA DX,PATH1 ;ASCIIZ-строка

INT 21H ;Вызвать DOS

JC error ;Переход по ошибке

MOV CUSTHAN,AX ;Сохр. файловый номер

17.4.а\) MOV AH,ЗОН ;Ф-ция открытия файла

MOV AL,OO ;Только чтение

LEA DX,PATH1 ;ASCIIZ-строка

INT 21H ;Вызвать OOS

JC error ;Переход по ошибке

MOV CUSTHAN.AX ;Сохр. файловый номер

17.5. При открытии большого числа файлов.

18.1. Используйте INT 13H и AH = 00.

18.2. Используйте INT 13H и AH = 01.

18.4. MOV АН,03 ;Функция записи

MOV AL,03 ;3 сектора

LEA BX,OUTDSK ;0бласть вывода

MOV CH,08 ;Дорожка 08

MOV CL,01 ;Сектор 01

MOV ОН,00 ;Сторона 0

MOV DL,01 ;Дисковод В

INT 13H

18.5. Байт состояния в регистре АН содержит 00000011.

19.2. а\) MOV AH,05 ;Функция печати

MOV DL,0CH ;Перевод страницы

INT 21H

б\) LEA SI,NAMEFLD ;Инициализ. имени

MOV CX,length ; и длины

В20:

MOV AH,05 ;Функция печати

MOV DL,\[SI\] ;Символ из имени

INT 21H ;Вызвать DOS

INC SI ;Следующий символ в имени

LOOP В20 ;Циклить length раз

в\) Можно закодировать символ перевод строки \(0А\) в начале адреса.

Решение аналогично б\),

д\) Вывести еще символ перевода страницы \(0С\).

19.3. HEADNG DB 13, 10, 15, 'Title', 12

19.5. Нельзя использовать регистр CX для пятикратного цикла, так как

внутренний цикл печати имени уже использует этот регистр.Для регистра

BX цикл будет следующим:

MOV BX,05

С20:

DEC BX

JNZ С20

20.1. a\) .SAIL.

20.2. a\) MULTBY MACRO MULTPR,MULTCD

MOV AL,MULTCD

MUL MULTPR

ENDM

20.3. Для включения библиотеки макрокоманд только в первом проходе

необходимо кодировать:

IF1

INCLUDE library-name

ENDIF

20.4. Макроопределение должно начинаться следующим образом:

BIPRINT MACRO PRTLINE,PRLEN

PRTLINE и PRLEN являются фиктивными аргументами для адреса и

длины строки, которая предназначена для печати. Для печати с помощью

BIOS INT 17H см. гл.19.

20.5.Проверку IF нельзя использовать для тестирования на нулевой делитель.

Проверка IF работает только в процессе ассемблирования, в то время

как тестирование на нулевой делитель должно происходить при

выполнении программы. Используйте, например, следующие команды:

CMP DIVISOR,00 ;Нулевой делитель?

JNZ \(обойти\) ;Нет - обойти

CALL \(подпрограмма вывода сообщения об ошибке\)

21.1. a\) EXTRN SUBPRO:FAR

21.2. a\) PUBLIC QTY,VALUE.PRICE

21.3. Для примера используйте рис.21.5.

21.4. В качестве примера передачи параметров используйте рис.21.5. Отличие

состоит в том, что в данном случае используется запись в Стек трех

переменных. Поэтому вызываемая программа для доступа к третьему

элементу \(PRICE\) в стеке использует \[BP+10\]. Можно определить

собственный стандарт для возврата элемента PRICE через стек. Обратите

внимание также на операнд в команде возврата RET.

21.5. Данная программа включает материал из cледующих глав: 8 \(ввод-вывод

на экран\), 13 \(преобразование между ASCII- и двоичным

представлением\), 12 \(двоичное умножение\) и 21 \(связь подпрограмм\).

Будьте особенно внимательны при работе со стеком.



[https://studfile.net/preview/893973/page:25/](https://studfile.net/preview/893973/page:25/)

